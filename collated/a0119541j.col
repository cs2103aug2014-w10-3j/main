//@author: a0119541j



	/**
	 * origin: src\sg\codengineers\ldo\logic\CreateHandler.java
	 */

import java.sql.Time;
import java.text.ParseException;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import sg.codengineers.ldo.model.AdditionalArgument;
import sg.codengineers.ldo.model.Command.CommandType;
import sg.codengineers.ldo.model.Result;
import sg.codengineers.ldo.model.Task;
import sg.codengineers.ldo.parser.ResultImpl;

public class CreateHandler extends Handler {

	public CreateHandler(List<Task> taskList) {
		super(taskList);
	}

	@Override
	public Result execute(String primaryOperand,Iterator<AdditionalArgument> iterator) throws IllegalArgumentException{

		if(primaryOperand == null){
			return null;
		}

		Task task = new TaskImpl(primaryOperand);


		AdditionalArgument arg = null;
		while(iterator.hasNext()){
			try{
				arg = iterator.next();
				modifyTask(task, arg);
			} catch (Exception e){
				if(arg != null){
					return new ResultImpl(CommandType.INVALID, 
							"Invalid argument "+arg.getOperand()+".",
							new Time(System.currentTimeMillis()));						
				} else {
					return new ResultImpl(CommandType.INVALID, 
							"Invalid argument.",
							new Time(System.currentTimeMillis()));		
				}

			}
		}



		_taskList.add(task);

		Result result = new ResultImpl(CommandType.CREATE, 
				primaryOperand,
				new Time(System.currentTimeMillis()), 
				task);

		return result;

	}

}

	// End of segment: src\sg\codengineers\ldo\logic\CreateHandler.java





	/**
	 * origin: src\sg\codengineers\ldo\logic\DeleteHandler.java
	 */

import java.sql.Time;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import sg.codengineers.ldo.model.AdditionalArgument;
import sg.codengineers.ldo.model.Command;
import sg.codengineers.ldo.model.Result;
import sg.codengineers.ldo.model.Task;
import sg.codengineers.ldo.model.Command.CommandType;
import sg.codengineers.ldo.parser.ResultImpl;

public class DeleteHandler extends Handler {

	public DeleteHandler(List<Task> taskList) {
		super(taskList);
	}

	@Override
	public Result execute(String primaryOperand,
			Iterator<AdditionalArgument> iterator) {
		
		Result result = null;
		Task task = null;
		
		if(primaryOperand.equalsIgnoreCase("all")){
			List<Task> theList = new ArrayList<Task>(_taskList);
			_taskList.clear();
			indexMap.clear();
			result = new ResultImpl(CommandType.DELETE, 
					primaryOperand,
					new Time(System.currentTimeMillis()), 
					theList);	
			return result;
		}
		int id = -1;
		try{
			id = Integer.valueOf(primaryOperand) - DIFFERENCE_DIPSLAY_INDEX_AND_SYSTEM_INDEX;
			task = getTask((int)indexMap.get(id));
			_taskList.remove(task);
			indexMap.remove(Integer.valueOf(id));
		} catch(Exception e){
			if(Logic.DEBUG){
				e.printStackTrace();
			}
			return new ResultImpl(CommandType.INVALID, 
					"Task "+primaryOperand+" doesn't exist.",
					new Time(System.currentTimeMillis()));		
		}
		
		result = new ResultImpl(CommandType.DELETE, 
				primaryOperand,
				new Time(System.currentTimeMillis()), 
				task);		
		return result;
	}

}

	// End of segment: src\sg\codengineers\ldo\logic\DeleteHandler.java





	/**
	 * origin: src\sg\codengineers\ldo\logic\Filter.java
	 */

/**
 * An interface that wraps a filter method to simulate "pass in functions as parameters".<br>
 * You are strongly suggested to use anonymous classes to implement this interface.
 * @param <E> the type of input that {@link Filter#call(Object)} method checks.
 */
public interface Filter<E> {
	public boolean call(E item);
}

	// End of segment: src\sg\codengineers\ldo\logic\Filter.java





	/**
	 * origin: src\sg\codengineers\ldo\logic\Handler.java
	 */

import java.sql.Time;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import sg.codengineers.ldo.model.AdditionalArgument;
import sg.codengineers.ldo.model.Parser;
import sg.codengineers.ldo.model.Result;
import sg.codengineers.ldo.model.Task;
import sg.codengineers.ldo.model.Command.CommandType;
import sg.codengineers.ldo.model.Task.Priority;
import sg.codengineers.ldo.parser.ParserImpl;
import sg.codengineers.ldo.parser.ResultImpl;
import sg.codengineers.ldo.logic.Filter;

/**
 * Abstract class for logic operations. <br>
 * It provides some basic utility functions for task manipulations. Concrete
 * logic operation classes need to implement {@link #execute(String, Iterator)}
 * method and fill in the actual execution there.
 * 
 *
 */
public abstract class Handler {
	// Difference between display index which starts from 1 and system index
	// which starts from 0
	protected static int DIFFERENCE_DIPSLAY_INDEX_AND_SYSTEM_INDEX = 1;
	protected Parser _parser;
	public static Map<Integer, Integer> indexMap = new HashMap<Integer, Integer>();

	public static boolean DEBUG_MODE = false;
	
	/**
	 * SimpleDateFormat no longer in use. Changed to Parser parseToDate method.
	 */
	// public final static SimpleDateFormat FORMATTER = new
	// SimpleDateFormat("dd/MM/yyyy");
	
	protected List<Task> _taskList;

	/**
	 * The actual operation needs to be implemented in concrete classes.
	 * 
	 * @param primaryOperand
	 * @param iterator
	 * @return a {@link sg.codengineers.ldo.model.Result Result} object
	 *         containing the retrieval result or feedbacks from other
	 *         operations. Will return <code>null</code> if the execution is
	 *         unsuccessful.
	 * @throws IllegalArgumentException
	 *             Thrown when the handler cannot parse the input parameters.
	 */
	abstract public Result execute(String primaryOperand,
			Iterator<AdditionalArgument> iterator)
			throws IllegalArgumentException;

	public Handler(List<Task> taskList) {
		this._taskList = taskList;
		this._parser = new ParserImpl();
	}

	/**
	 * Modify a task according to the input {@link AdditionalArgument}. <br>
	 * 
	 * <ul>
	 * <li>Argument type <code>HELP</code> is not implemented yet.</li>
	 * <li>Argument type <code>PRIORITY DONE TAG</code> are written into a same
	 * field <code>_tag</code> in {@link TaskImpl}.</li>
	 * <li>No exception will be thrown!</li>
	 * </ul>
	 * 
	 * @param task
	 *            the {@link Task} object to be modified.
	 * @param arg
	 *            the {@link AdditionalArgument} containing modification
	 *            information.
	 */
	protected void modifyTask(Task task, AdditionalArgument arg)
			throws ParseException, IllegalArgumentException {
		String operand = arg.getOperand();

		switch (arg.getArgumentType()) {
		case NAME:
			task.setName(operand);
			break;
		case DEADLINE:
			Date d = _parser.parseToDate(operand);
			if (d != null) {
				task.setDeadline(d);
			} else {
				throw new IllegalArgumentException("Wrong date format: "
						+ operand);
			}
			break;
		case TIME:
			String[] sOperand = operand.split("\\s+");
			if (sOperand.length != 2) {
				break;
			} else {
				Date startDate = _parser.parseToDate(sOperand[0]);
				Date endDate = _parser.parseToDate(sOperand[1]);
				if (startDate != null && endDate != null) {
					task.setTimeStart(startDate);
					task.setTimeEnd(endDate);
				} else {
					throw new IllegalArgumentException("Wrong date format: "
							+ operand);
				}
			}
			break;
		case PRIORITY:
			Task.Priority priority = Priority.fromString(operand);
			if (priority != null) {
				task.setPriority(priority);
			} else {
				throw new IllegalArgumentException();
			}
			break;
		case TAG:
			task.setTag(operand);
			break;
		case DESCRIPTION:
			task.setDescription(operand);
			break;
		case HELP:
		case INVALID:
		default:
			throw new IllegalArgumentException();
		}
	}

	/**
	 * Search through a {@link List} of {@link Task} according to the input
	 * {@link AdditionalArgument}.
	 * 
	 * <ul>
	 * <li><code>name</code> field and <code>description</code> field are
	 * checked using {@link String#contains(String)} method.</li>
	 * <li><code>tag</code> field is checked using
	 * {@link String#equalsIgnoreCase(String)} method.</li>
	 * <li><code>deadline</code> field is checked using
	 * {@link Date#compareTo(Date)} method. A task will be taken as a valid
	 * return value if and only if:
	 * <ol>
	 * <li><code>taskDeadline >= today</code> and,</li>
	 * <li><code>taskDeadline <= inputDeadline</code></li>
	 * </ol>
	 * <li><code>time</code> field is checked using {@link Date#compareTo(Date)}
	 * method. A task will be taken as a valid return value if and only if its
	 * <code>time</code> field overlaps with the input time.</li>
	 * </ul>
	 * 
	 * @param list
	 *            a {@link List} of {@link Task} objects from which the
	 *            searching result will be constructed.
	 * @param arg
	 *            a {@link AdditionalArgument} object containing the search
	 *            parameter.
	 * @return a {@link List} of {@link Task} objects containing the search
	 *         result. Note that this return list contains the original
	 *         references to the task objects which are directly obtained from
	 *         the input list.
	 */
	protected List<Task> searchTask(List<Task> list, AdditionalArgument arg) {
		List<Task> newList = new ArrayList<Task>(list);
		final String operand = arg.getOperand();

		try {
			switch (arg.getArgumentType()) {
			case NAME:
				newList = filter(newList, new Filter<Task>() {
					@Override
					public boolean call(Task task) {
						boolean x = task.getName().contains(operand);
						// System.out.println(x);
						return x;
					}
				});
				break;
			case DEADLINE:
				final Date deadline = _parser.parseToDate(operand);
				if (deadline == null) {
					throw new IllegalArgumentException("Wrong date format: "
							+ operand);
				}
				newList = filter(newList, new Filter<Task>() {
					@Override
					public boolean call(Task task) {
						Date dd = task.getDeadline();
						if(dd == null){
							return false;
						}
						return dd.compareTo(deadline) <= 0
								&& dd.compareTo(new Date()) >= 0;
					}
				});
				break;
			case TIME:
				String[] sOperand = operand.split("\\s+");
				if ((sOperand.length == 2 && !sOperand[0].isEmpty() && sOperand[1]
						.isEmpty())
						|| (sOperand.length == 1 && !sOperand[0].isEmpty())) {
					final Date date = _parser.parseToDate(sOperand[0]);
					if (date == null) {
						throw new IllegalArgumentException(
								"Wrong date format: " + operand);
					}
					newList = filter(newList, new Filter<Task>() {
						@Override
						public boolean call(Task task) {
							Date ts = task.getStartTime();
							Date te = task.getEndTime();
							Date ddl = task.getDeadline();
							if (ddl != null) {
								if (ddl.compareTo(date) <= 0
										&& ddl.compareTo(new Date()) >= 0) {
									return true;
								}
							}
							if (ts != null && te != null) {
								if (te.compareTo(date) >= 0
										&& ts.compareTo(date) <= 0) {
									return true;
								}
							}
							return false;
						}
					});
				} else if (sOperand.length == 2 && !sOperand[0].isEmpty()
						&& !sOperand[1].isEmpty()) {

					final Date startDate = _parser.parseToDate(sOperand[0]);
					final Date endDate = _parser.parseToDate(sOperand[1]);
					if (startDate == null || endDate == null) {
						throw new IllegalArgumentException(
								"Wrong date format: " + operand);
					}
					newList = filter(newList, new Filter<Task>() {
						@Override
						public boolean call(Task task) {
							Date ts = task.getStartTime();
							Date te = task.getEndTime();
							if (ts == null || te == null) {
								return false;
							} else {
								return (ts.compareTo(endDate) <= 0 && ts
										.compareTo(startDate) >= 0)
										|| (te.compareTo(startDate) >= 0 && te
												.compareTo(endDate) <= 0);
							}
						}
					});
				} else {
					throw new IllegalArgumentException(
							"Please specify both start date and end date");
				}
				break;
			case PRIORITY:
				final Task.Priority priority = Priority.fromString(operand);
				if (priority != null) {
					newList = filter(newList, new Filter<Task>() {
						@Override
						public boolean call(Task task) {
							if (task.getPriority() == priority) {
								return true;
							}
							return false;
						}
					});
				}
				break;
			case TAG:
				newList = filter(newList, new Filter<Task>() {
					@Override
					public boolean call(Task task) {
						return task.getTag().equalsIgnoreCase(operand);
					}
				});
				break;
			case DESCRIPTION:
				newList = filter(newList, new Filter<Task>() {
					@Override
					public boolean call(Task task) {
						return task.getDescription().contains(operand);
					}
				});
				break;
			case HELP:
			case INVALID:
			default:
				break;
			}
		} catch (Exception e) {
			if (Logic.DEBUG)
				e.printStackTrace();
			throw e;
		}
		return newList;
	}

	/**
	 * Apply a {@link Filter} to all input {@link List} of {@link Task} objects
	 * and construct a return {@link List} of tasks that are evaluated to
	 * <code>true</code> by the {@link Filter}.
	 * 
	 * @param list
	 *            a {@link List} of {@link Task} objects.
	 * @param f
	 *            a {@link Filter} that implements a {@link Filter#call(Object)}
	 *            method.
	 * @return a {@link List} of {@link Task} objects. Note that the task
	 *         references inside the list refer to the same tasks in the input
	 *         list.
	 */
	private List<Task> filter(List<Task> list, Filter<Task> f) {
		List<Task> newList = new ArrayList<Task>();

		for (Task task : list) {
			if (f.call(task)) {
				newList.add(task);
			}
		}
		return newList;
	}

	/**
	 * Construct a {@link Result} object.
	 * 
	 * @param operand
	 *            the primary operand of a {@link Command}
	 * @param task
	 *            the targeted {@link Task} of the command.
	 * @return a {@link Result} object wrapping the input and current time
	 *         information.
	 * @see Handler#constructResult(String, List)
	 */
	protected Result constructResult(String operand, Task task) {
		return new ResultImpl(CommandType.RETRIEVE, operand, new Time(
				System.currentTimeMillis()), task);
	}

	/**
	 * Construct a {@link Result} object.
	 * 
	 * @param operand
	 *            the primary operand of a {@link Command}
	 * @param list
	 *            the targeted {@link List} of {@link Task} of the command.
	 * @return a {@link Result} object wrapping the input and current time
	 *         information.
	 * @see Handler#constructResult(String, Task)
	 */
	protected Result constructResult(String operand, List<Task> list) {
		return new ResultImpl(CommandType.RETRIEVE, operand, new Time(
				System.currentTimeMillis()), list);
	}

	protected Result constructResult(String operand) {
		return new ResultImpl(CommandType.RETRIEVE, operand, new Time(
				System.currentTimeMillis()));
	}

	public static List<Task> eliminateDoneTasks(List<Task> taskList) {
		List<Task> newList = new ArrayList<Task>();
		if (taskList != null) {
			for (int i = 0; i < taskList.size(); i++) {
				if (!taskList.get(i).getTag().equalsIgnoreCase("Done")) {
					newList.add(taskList.get(i));
				}
			}
		}
		return newList;
	}

	protected boolean isTagDone(AdditionalArgument arg) {
		if (arg == null) {
			return false;
		} else {
			if (arg.getArgumentType() == AdditionalArgument.ArgumentType.TAG
					&& arg.getOperand() != null
					&& arg.getOperand().equalsIgnoreCase("Done")) {
				return true;
			}
		}
		return false;
	}
	
	protected void populateIndexMap(List<Task> list){
		if(list != null && list.size() > 0){
			indexMap.clear();
			for(int i = 0; i < list.size();i ++){
				indexMap.put(i, list.get(i).getId());
			}			
		}

		
	}
	
	protected Task getTask(int uId){
		for(Task t : _taskList){
			if(t.getId() == uId){
				return t;
			}
		}
		throw new IllegalArgumentException();
	}

}

	// End of segment: src\sg\codengineers\ldo\logic\Handler.java





	/**
	 * origin: src\sg\codengineers\ldo\logic\HelpHandler.java
	 */

import java.sql.Time;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;

import sg.codengineers.ldo.model.AdditionalArgument;
import sg.codengineers.ldo.model.Command.CommandType;
import sg.codengineers.ldo.model.Result;
import sg.codengineers.ldo.model.Task;
import sg.codengineers.ldo.parser.ResultImpl;

public class HelpHandler extends Handler{
//	public  String MSG_AA_TIME = "\t\t-t/--time <start time> <end time>\t\t set the start time and end time for the task.\n";
//	public  String MSG_AA_DEADLINE = "\t\t-d/--deadline <time>\t\t\t\t set the deadline time for the task.\n";
//	public  String MSG_AA_NAME = "\t\t-n/--name <task name>\t\t\t\t set the name for the task.\n";
//	public  String MSG_AA_PRIORITY = "\t\t-p/--priority <priority level>\t\t\t set the priority level for the task. Can only be LOW, MEDIUM or HIGH.\n";
//	public  String MSG_AA_TAG = "\t\t--tag <tag name>\t\t\t\t set the tag for the task.\n";
//	public  String MSG_AA_DESCRIPTION = "\t\t-a/--description <description text>\t\t set the description for the task.\n";
//	public  String MSG_AA_HELP = "\t\t-h/--help \t\t\t\t\t display the help message for the command.";
//	public  String MSG_AA_ALL = MSG_AA_TIME + MSG_AA_DEADLINE
//			+ MSG_AA_NAME + MSG_AA_PRIORITY + MSG_AA_TAG + MSG_AA_DESCRIPTION
//			+ MSG_AA_HELP;
//	public  String HELP_MSG_CREATE = "Help message for command *add*\n\tUsage: add <taskname> [<parameters>]\n\tParameters:\n"
//			+ MSG_AA_ALL;
//	public  String HELP_MSG_SEARCH = "Help message for command *search*\n\tUsage: search <taskname> \n\t\t search [<parameters>]\n\tParameters:\n"
//			+ MSG_AA_ALL;
//	public  String HELP_MSG_UPDATE = "Help message for command *update*\n\tUsage: update <task index> [<parameters>]\n\tParameters:\n"
//			+ MSG_AA_ALL;
//	public  String HELP_MSG_DELETE = "Help message for command *delete*\n\tUsage: delete <task index>";
//	public  String HELP_MSG_SHOW = "Help mesasge for command *show*\n\tUsage: show\n\t\tshow <task index>";
//	public  String HELP_MSG_HELP = "Help message for command *help*\n\tUsage: help <command> [<parameters>]\n\t"
//			+ "Note: Currently support add, update, delete, show, search, help.\n\tParameters:\n"
//			+ MSG_AA_HELP;
	public  String HELP_MSG_CREATE = "Help message for command *add*\n\tUsage: add <taskname> [<parameters>]\n\tParameters:\n\t\t-t/--time <start time> <end time>\t\t set the start time and end time for the task.\n\t\t-d/--deadline <time>\t\t\t\t set the deadline time for the task.\n\t\t-n/--name <task name>\t\t\t\t set the name for the task.\n\t\t-p/--priority <priority level>\t\t\t set the priority level for the task. Can only be LOW, NORMAL or HIGH.\n\t\t--tag <tag name>\t\t\t\t set the tag for the task. note that once a task is tagged \"done\", it will never appear in your task list unless you search for \"--tag done\"\n\t\t --done \t\t\t\t\t alias of \"--tag done\".\n\t\t-a/--description <description text>\t\t set the description for the task.\n\t\t-h/--help \t\t\t\t\t display this help message\n.";
	public  String HELP_MSG_SEARCH = "Help message for command *search*\n\tUsage: search <taskname> \n\t\t search [<parameters>]\n\tParameters:\n\t\t-t/--time <start time> <end time>\t\t search using the start time and end time.\n\t\t-t/--time <time>\t\t\t\t\tsearch both the time and deadline.\n\t\t-d/--deadline <time>\t\t\t\t search the deadline time.\n\t\t-n/--name <task name>\t\t\t\t search the name.\n\t\t-p/--priority <priority level>\t\t\t search the priority level. Can only be LOW, NORMAL or HIGH.\n\t\t--tag <tag name>\t\t\t\t search the tag.\n\t\t --done \t\t\t\t\t alias of \"--tag done\".\n\t\t-a/--description <description text>\t\t search the description.\n\t\t-h/--help \t\t\t\t\t display this help message\n.";
	public  String HELP_MSG_UPDATE = "Help message for command *update*\n\tUsage: update <task index> [<parameters>]\n\tParameters:\n\t\t-t/--time <start time> <end time>\t\t set the start time and end time for the task.\n\t\t-d/--deadline <time>\t\t\t\t set the deadline time for the task.\n\t\t-n/--name <task name>\t\t\t\t set the name for the task.\n\t\t-p/--priority <priority level>\t\t\t set the priority level for the task. Can only be LOW, NORMAL or HIGH.\n\t\t--tag <tag name>\t\t\t\t set the tag for the task. note that once a task is tagged \"done\", it will never appear in your task list unless you search for \"--tag done\"\n\t\t--done \t\t\t\t\t alias of \"--tag done\".\n\t\t-a/--description <description text>\t\t set the description for the task.\n\t\t-h/--help \t\t\t\t\t display this help message\n.";
	public String HELP_MSG_UNDO = "Help message for command *undo*\n\tUsage: undo\n\tDescription: It will recover the previous command. If this is the first command, nothing will be done.\n";
	public  String HELP_MSG_DELETE = "Help message for command *delete*\n\tUsage: delete <task index>\n";
	public  String HELP_MSG_SHOW = "Help mesasge for command *show*\n\tUsage: show [<task index>]\t\t\t\tshow all available tasks or view a tasks with a specific index.\n";
	public  String HELP_MSG_HELP = "Help message for command *help*\n\tUsage: help <command> [<parameters>]\n\tNote: Currently support add, update, delete, show, search, help, undo.\n\tParameters:\n\t\t-h/--help \t\t\t\t\t display this help message\n.";
	private Map<CommandType, String> _map = new HashMap<CommandType, String>();

	public HelpHandler(List<Task> taskList) {
		super(taskList);
		_map.put(CommandType.CREATE, HELP_MSG_CREATE);
		_map.put(CommandType.UPDATE, HELP_MSG_UPDATE);
		_map.put(CommandType.SEARCH, HELP_MSG_SEARCH);
		_map.put(CommandType.DELETE, HELP_MSG_DELETE);
		_map.put(CommandType.RETRIEVE, HELP_MSG_SHOW);
		_map.put(CommandType.HELP, HELP_MSG_HELP);
		_map.put(CommandType.UNDO, HELP_MSG_UNDO);
	}

	public Result execute(CommandType type) {
		Result result;
		try {
			if(type == null){
				throw new Exception();
			}
			//System.out.println("My result string is: " + _map.get(type));
			result = new ResultImpl(CommandType.HELP, _map.get(type), new Time(
					System.currentTimeMillis()));
		} catch (Exception e) {
			if (Logic.DEBUG) {
				e.printStackTrace();
			}
			result = new ResultImpl(CommandType.INVALID,
					"Invalid command type " + type + " for help.", new Time(
							System.currentTimeMillis()));
		}

		return result;

	}

	@Override
	public Result execute(String primaryOperand,
			Iterator<AdditionalArgument> iterator)
			throws IllegalArgumentException {
		//System.out.println(primaryOperand);
		//System.out.println(CommandType.fromString(primaryOperand));
		return execute(CommandType.fromString(primaryOperand));
	}

}

	// End of segment: src\sg\codengineers\ldo\logic\HelpHandler.java





	/**
	 * origin: src\sg\codengineers\ldo\logic\Logic.java
	 */

import java.io.IOException;
import java.sql.Time;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Stack;

import sg.codengineers.ldo.db.Database;
import sg.codengineers.ldo.model.AdditionalArgument;
import sg.codengineers.ldo.model.Command;
import sg.codengineers.ldo.model.Command.CommandType;
import sg.codengineers.ldo.model.Result;
import sg.codengineers.ldo.model.Task;
import sg.codengineers.ldo.parser.ResultImpl;

/**
 * Logic class provides basic manipulation functions of tasks and task lists. <br>
 * To construct a Logic instance, please call {@link Logic#getLogic()}. There
 * will be only one Logic instance alive at a time.
 */
public class Logic {
	private static String MSG_SYNC_SUCCESS = "Sync to Google Calendar successful.\n";
	private static String MSG_SYNC_FAIL = "Sync to Google Calendar failed.\n";

	private Database _dbConnector;
	private List<Task> _taskList;
	private Stack<List<Task>> _listStack;
	private Stack<Command> _commandStack;
	private Stack<Map<Integer, Integer>> _mapStack;
	private boolean _isInitialized = false;

	private Handler createHandler, searchHandler, updateHandler, deleteHandler,
			showHandler;
	private HelpHandler helpHandler;

	private static Logic instance = null;
	public static final boolean DEBUG = false;

	public static Logic getInstance() {
		try {
			if (instance == null) {
				instance = new Logic();
			}
		} catch (Exception e) {
			if (Logic.DEBUG) {
				e.printStackTrace();
			}
		}
		return instance;
	}

	private Logic() throws Exception {
		try {
			this._dbConnector = Database.initDatabase();
			initialize();
		} catch (Exception e) {
			if (Logic.DEBUG) {
				e.printStackTrace();
			}
			throw e;
		}

	}

	protected Logic(boolean stub) {

	}

	private void initialize() throws Exception {
		if (_isInitialized) {
			return;
		}

		_taskList = new ArrayList<Task>();
		List<String> stringList = _dbConnector.read(TaskImpl.CLASS_NAME);
		for (String s : stringList) {
			Task newTask = TaskImpl.valueOf(s);
			if(newTask != null){
				_taskList.add(newTask);
			}
		}

		createHandler = new CreateHandler(_taskList);
		searchHandler = new SearchHandler(_taskList);
		updateHandler = new UpdateHandler(_taskList);
		deleteHandler = new DeleteHandler(_taskList);
		helpHandler = new HelpHandler(_taskList);
		showHandler = new ShowHandler(_taskList);
		_isInitialized = true;
		_listStack = new Stack<List<Task>>();
		_listStack.push(new ArrayList<Task>(_taskList));
		_commandStack = new Stack<Command>();
		_mapStack = new Stack<Map<Integer, Integer>>();
	}

	public Result createTask(Command command) throws IOException {
		Result result = null;
		try {
			String primaryOperand = command.getPrimaryOperand();
			Iterator<AdditionalArgument> iterator = command
					.getAdditionalArguments();
			result = createHandler.execute(primaryOperand, iterator);
			_listStack.push(new ArrayList<Task>(_taskList));
			_commandStack.push(command);
			_mapStack.push(new HashMap<Integer, Integer>(Handler.indexMap));
			_dbConnector.create(result.getTasksIterator().next(),
					TaskImpl.CLASS_NAME);			
		} catch (Exception e) {
			if (DEBUG) {
				e.printStackTrace();
			}
			result = new ResultImpl(CommandType.INVALID,
					"Can't create task with " + command.getUserInput(),
					new Time(System.currentTimeMillis()));
		}

		return result;
	}

	public Result deleteTask(Command command) throws IOException {
		Result result;
		try {
			String primaryOperand = command.getPrimaryOperand();
			Iterator<AdditionalArgument> iterator = command
					.getAdditionalArguments();
			result = deleteHandler.execute(primaryOperand, iterator);
			Iterator<Task> it = result.getTasksIterator();
			_listStack.push(new ArrayList<Task>(_taskList));
			_commandStack.push(command);
			_mapStack.push(new HashMap<Integer, Integer>(Handler.indexMap));
			while(it != null && it.hasNext()){
				_dbConnector.delete(it.next(),
						TaskImpl.CLASS_NAME);				
			}			
		} catch (Exception e) {
			if(DEBUG){
				e.printStackTrace();
			}
			return new ResultImpl(CommandType.INVALID,
					"Cannot delete task with " + command.getUserInput(),
					new Time(System.currentTimeMillis()));
		}

		return result;
	}

	public Result updateTask(Command command) throws IOException {
		Result result;
		try {
			String primaryOperand = command.getPrimaryOperand();
			Iterator<AdditionalArgument> iterator = command
					.getAdditionalArguments();
			result = updateHandler.execute(primaryOperand, iterator);
			_listStack.push(new ArrayList<Task>(_taskList));
			_commandStack.push(command);
			_mapStack.push(new HashMap<Integer, Integer>(Handler.indexMap));
			_dbConnector.update(result.getTasksIterator().next(),
					TaskImpl.CLASS_NAME);			
		} catch (Exception e) {
			if(DEBUG){
				e.printStackTrace();
			}
			return new ResultImpl(CommandType.INVALID,
					"Cannot update task with " + command.getUserInput(),
					new Time(System.currentTimeMillis()));
		}
		return result;
	}

	public Result searchTask(Command command) {
		try {
			String primaryOperand = command.getPrimaryOperand();
			Iterator<AdditionalArgument> iterator = command
					.getAdditionalArguments();
			return searchHandler.execute(primaryOperand, iterator);
		} catch (Exception e) {
			return new ResultImpl(CommandType.INVALID,
					"Cannot search for task with " + command.getUserInput(),
					new Time(System.currentTimeMillis()));
		}

	}

	public Result showTask(Command command) {
		int index = -1;
		if (command.getPrimaryOperand() == null
				|| command.getPrimaryOperand().isEmpty()
				|| command.getPrimaryOperand().equalsIgnoreCase("all")) {
			return showHandler.execute(String.valueOf(index), null);
		}
		try {
			index = Integer.valueOf(command.getPrimaryOperand());
		} catch (Exception e) {
			if (DEBUG) {
				e.printStackTrace();
			}
			return new ResultImpl(CommandType.INVALID, "Task "
					+ command.getPrimaryOperand() + " doesn't exist.",
					new Time(System.currentTimeMillis()));
		}
		return showHandler.execute(String.valueOf(index), null);
	}

	public Result undoTask() {
		_taskList.clear();
		if (_listStack.size() > 1) {
			_listStack.pop();
			_taskList.addAll(_listStack.peek());
		}
		String userInput = null;
		if (!_commandStack.isEmpty()) {
			userInput = _commandStack.pop().getUserInput();
		}
		Task task = null;
		Handler.indexMap.clear();
		if(!_mapStack.isEmpty()){
			Handler.indexMap.putAll(_mapStack.pop());
		}
		return new ResultImpl(CommandType.UNDO, userInput, new Time(
				System.currentTimeMillis()), task);
	}

	public Result showHelp(Command command) {
		try {
			return helpHandler.execute(command.getPrimaryOperand(), null);
		} catch (Exception e) {
			return new ResultImpl(CommandType.INVALID,
					"Cannot find HELP page with " + command.getUserInput(),
					new Time(System.currentTimeMillis()));
		}

	}
	
	// End of segment: src\sg\codengineers\ldo\logic\Logic.java





	/**
	 * origin: src\sg\codengineers\ldo\logic\SearchHandler.java
	 */

import java.sql.Time;
import java.util.ArrayList;
import java.util.Iterator;
import java.util.List;

import sg.codengineers.ldo.model.AdditionalArgument;
import sg.codengineers.ldo.model.AdditionalArgument.ArgumentType;
import sg.codengineers.ldo.model.Result;
import sg.codengineers.ldo.model.Task;
import sg.codengineers.ldo.model.Command.CommandType;
import sg.codengineers.ldo.parser.AdditionalArgumentImpl;
import sg.codengineers.ldo.parser.ResultImpl;

public class SearchHandler extends Handler {
	
	private String pmOperand;
	private boolean isDone = false;
	
	public SearchHandler(List<Task> taskList) {
		super(taskList);
	}

	@Override
	public Result execute(String primaryOperand,
			Iterator<AdditionalArgument> iterator) {
		isDone = false;
		pmOperand = primaryOperand;
		Result result = null;
		List<Task> resultList = null;
		
		boolean isOpEmpty = primaryOperand == null || primaryOperand.equals("");
		boolean isItEmpty = iterator == null || !iterator.hasNext();
		
		if(isOpEmpty && isItEmpty){
			return new ResultImpl(CommandType.INVALID, 
					"Search for nothing is not allowed!",
					new Time(System.currentTimeMillis()));
		}
		
		if(!isOpEmpty && isItEmpty){
			resultList = new ArrayList<Task>(_taskList);
			AdditionalArgument arg = new AdditionalArgumentImpl(AdditionalArgument.ArgumentType.NAME, primaryOperand);
			resultList = searchTask(resultList, arg);
			String opString = populateAddArg("", arg);
			resultList = eliminateDoneTasks(resultList);
			result = constructResult(opString, resultList);
		} 
		
		if(!isItEmpty){
			resultList = new ArrayList<Task>(_taskList);
			AdditionalArgument arg = null;
			String opString = "";
			if(!isOpEmpty){
				arg = new AdditionalArgumentImpl(AdditionalArgument.ArgumentType.NAME, primaryOperand);
				resultList = searchTask(resultList, arg);	
				opString = populateAddArg(opString, arg);
			}
			while(iterator.hasNext()){
				arg =  iterator.next();
				isDone = isDone || isTagDone(arg);
				resultList = searchTask(resultList, arg);
				opString = populateAddArg(opString, arg);
			}
			if(!isDone){
				resultList = eliminateDoneTasks(resultList);
			}
			result = constructResult(opString, resultList);
		} 		
		populateIndexMap(resultList);
		return result;
	}

	private String populateAddArg(String accString, AdditionalArgument arg){
		if(!accString.isEmpty()){
			accString+=" and ";
		}
		accString += arg.getArgumentType().toString() + " "+arg.getOperand();
		return accString;
	}
}

	// End of segment: src\sg\codengineers\ldo\logic\SearchHandler.java





	/**
	 * origin: src\sg\codengineers\ldo\logic\ShowHandler.java
	 */

import java.sql.Time;
import java.util.Iterator;
import java.util.List;

import sg.codengineers.ldo.model.AdditionalArgument;
import sg.codengineers.ldo.model.Result;
import sg.codengineers.ldo.model.Task;
import sg.codengineers.ldo.model.Command.CommandType;
import sg.codengineers.ldo.parser.ResultImpl;

public class ShowHandler extends Handler {
	public ShowHandler(List<Task> taskList) {
		super(taskList);
	}

	public Result execute(int index) {
		if (index == -1) {
			List<Task> showList = eliminateDoneTasks(_taskList);
			populateIndexMap(showList);
			return new ResultImpl(CommandType.RETRIEVE, "all", new Time(
					System.currentTimeMillis()),
					showList);
		}
		Task task = null;
		try {
			task = _taskList.get(index - 1);
		} catch (Exception e) {
			if (Logic.DEBUG) {
				e.printStackTrace();
			}
			return new ResultImpl(CommandType.INVALID, "Task " + index
					+ " doesn't exist.", new Time(System.currentTimeMillis()));
		}
		return new ResultImpl(CommandType.RETRIEVE, String.valueOf(index),
				new Time(System.currentTimeMillis()), task);
	}

	@Override
	public Result execute(String primaryOperand,
			Iterator<AdditionalArgument> iterator)
			throws IllegalArgumentException {
		return execute(Integer.valueOf(primaryOperand));
	}
}

	// End of segment: src\sg\codengineers\ldo\logic\ShowHandler.java





	/**
	 * origin: src\sg\codengineers\ldo\logic\TaskImpl.java
	 */

import java.text.ParseException;
import java.util.Date;

import sg.codengineers.ldo.model.Parser;
import sg.codengineers.ldo.model.Task;
import sg.codengineers.ldo.parser.ParserImpl;

public class TaskImpl implements Task {
	public static String CLASS_NAME = "TASK";
	public static Parser parser = new ParserImpl();
	
	public static int FIELD_ID_INDEX = 0;
	public static int FIELD_NAME_INDEX = 1;
	public static int FIELD_DESCRIPTION_INDEX = 2;
	public static int FIELD_TAG_INDEX = 3;
	public static int FIELD_TIMESTART_INDEX = 4;
	public static int FIELD_TIMEEND_INDEX = 5;
	public static int FIELD_PRIORITY_INDEX = 6;
	public static int FIELD_DELETED_INDEX = 7;
	
	public static int FIELD_COUNT = 7;
	public static int FIELD_COUNT_DELETED = 8;
	
	private int _id;
	private String _name, _description, _tag;
	private Date _timeStart, _timeEnd;
	private Priority _priority;
	
	private static int _accumulateId = -1;
	
	public TaskImpl(String name) {
		_id = getNextId();
		_name = name;
		_description = _tag = "";
		_timeStart = _timeEnd = null;
		_priority = Priority.NORMAL;
	}
	
	/**
	 * Construct a new task by copying all information from the input task.
	 * @param task The {@link Task} object from which the information will be copied
	 */
	public TaskImpl(Task task){
		this._id = task.getId();
		this._name = task.getName();
		this._tag = task.getTag();
		this._timeStart = task.getStartTime();
		this._timeEnd = task.getEndTime();
		this._description = task.getDescription();
		this._priority = task.getPriority();
	}
	
	/**
	 * Constructs a Task object for manipulation
	 */
	public TaskImpl() {
		
	}
	
	/**
	 * Generate a unique ID for a new task.
	 * @return the unique ID in integer format.
	 */
	public static int getNextId(){
		_accumulateId ++;
		return _accumulateId;
	}
	
	@Override
	public int getId() {
		return _id;
	}

	@Override
	public String getName() {
		return _name;
	}

	@Override
	public String getTag() {
		return _tag;
	}
	
	@Override
	public String getDescription() {
		return _description;
	}

	@Override
	public Date getStartTime() {
		return _timeStart;
	}

	@Override
	public Date getEndTime() {
		return _timeEnd;
	}

	@Override
	public Date getDeadline() {
		// Deadline tasks have the same start and end time
		if(_timeStart!=null){
			if(_timeStart.equals(_timeEnd)){
				return _timeStart;
			}		
		}

		return null;
	}
	
	public void setId(int id) {
		_id = id;	
	}
	
	public void setName(String name){
		_name = name;
	}
	
	public void setTag(String tag) {
		_tag = tag;
	}
	
	public void setDescription(String description) {
		_description = description;
	}
	
	public void setTimeStart(Date timeStart) {
		_timeStart = timeStart;
	}
	
	public void setTimeEnd(Date timeEnd) {
		_timeEnd = timeEnd;
	}
	
	public void setDeadline(Date deadline) {
		_timeStart = deadline;
		_timeEnd = deadline;
	}
	
	@Override
	public String toString(){	
		StringBuilder builder = new StringBuilder();
		builder.append(_id+"<;>");
		builder.append(_name+"<;>");
		builder.append(_description+"<;>");
		builder.append(_tag+"<;>");
		if(_timeStart != null && _timeEnd !=null){
			builder.append(parser.parseDateToString(_timeStart)+"<;>");
			builder.append(parser.parseDateToString(_timeEnd)+"<;>");		
		}else{
			builder.append("<;>");
			builder.append("<;>");
		}

		builder.append(_priority);
		return builder.toString();
	}
	
	public static Task valueOf(String s) throws ParseException{
		if(s == null || s.isEmpty()) return null;

		Task task = null;
		
		String taskArgs[] = s.split("<;>");
		
		if(taskArgs.length != FIELD_COUNT && taskArgs.length!= FIELD_COUNT_DELETED){
			throw new ParseException("Cannot parse file texts", taskArgs.length);
		} else {
			
			int id = Integer.valueOf(taskArgs[FIELD_ID_INDEX]);
			
			if(_accumulateId <= id){
				_accumulateId = id + 1;
			}
			
			if(taskArgs.length == FIELD_COUNT_DELETED){
				return null;
			}
			
			String name = taskArgs[FIELD_NAME_INDEX];
			task = new TaskImpl(name);
			task.setId(id);
			
			String description = taskArgs[FIELD_DESCRIPTION_INDEX];
			if(description!= null && !description.isEmpty()){
				task.setDescription(description);
			}
			
			String tag = taskArgs[FIELD_TAG_INDEX];
			if(tag!= null && !tag.isEmpty()){
				task.setTag(tag);
			}				
			
			Date sTime = null;
			Date eTime = null;
			
			String timeStart = taskArgs[FIELD_TIMESTART_INDEX];
			if(timeStart!=null && !timeStart.isEmpty()){
				sTime = parser.parseToDate(timeStart);
			}
			
			String timeEnd = taskArgs[FIELD_TIMEEND_INDEX];
			if(timeEnd!=null && !timeEnd.isEmpty()){
				eTime = parser.parseToDate(timeEnd);
			}	
			
			if(sTime!=null && eTime!=null && sTime.equals(eTime)){
				task.setDeadline(sTime);
			} else {
				task.setTimeEnd(eTime);
				task.setTimeStart(sTime);
			}
			
			Priority priority = Priority.fromString(taskArgs[FIELD_PRIORITY_INDEX]);
			if(priority != null){
				task.setPriority(priority);
			}

		}
		
		return task;
	}

	@Override
	public Priority getPriority() {
		return _priority;
	}

	@Override
	public void setPriority(Priority priority) {
		this._priority = priority;
	}

	@Override
	public void setParams(Task task) {
		this._id = task.getId();
		this._name = task.getName();
		this._tag = task.getTag();
		this._timeStart = task.getStartTime();
		this._timeEnd = task.getEndTime();
		this._description = task.getDescription();
		this._priority = task.getPriority();
	}
}

	// End of segment: src\sg\codengineers\ldo\logic\TaskImpl.java





	/**
	 * origin: src\sg\codengineers\ldo\logic\UpdateHandler.java
	 */

import java.sql.Time;
import java.text.ParseException;
import java.util.Iterator;
import java.util.List;

import sg.codengineers.ldo.model.AdditionalArgument;
import sg.codengineers.ldo.model.Result;
import sg.codengineers.ldo.model.Task;
import sg.codengineers.ldo.model.Command.CommandType;
import sg.codengineers.ldo.parser.ResultImpl;

public class UpdateHandler extends Handler {
	public static final int INVALID_ID = -1;
	
	public UpdateHandler(List<Task> taskList) {
		super(taskList);
	}

	@Override
	public Result execute(String primaryOperand, Iterator<AdditionalArgument> iterator) {
		
		Task task = null;
		int taskId = INVALID_ID;
		
		try{
			if(primaryOperand != null){
				taskId = Integer.valueOf(primaryOperand) - DIFFERENCE_DIPSLAY_INDEX_AND_SYSTEM_INDEX;
				
				Task modifiedTask = new TaskImpl(getTask(indexMap.get(taskId)));
				
				while(iterator.hasNext()){
					AdditionalArgument arg = iterator.next();
					modifyTask(modifiedTask, arg);
				}
				
				task = modifiedTask;
			}
		} catch (Exception e){
			if(Logic.DEBUG){
				e.printStackTrace();
			}
			return new ResultImpl(CommandType.INVALID, 
					primaryOperand,
					new Time(System.currentTimeMillis()), 
					task);
			
		}
		
		if(taskId == INVALID_ID || task==null){			
			return new ResultImpl(CommandType.INVALID, 
					primaryOperand,
					new Time(System.currentTimeMillis()), 
					task);
		} else {
			getTask(indexMap.get(taskId)).setParams(task);
		}
		
		Result result = new ResultImpl(CommandType.UPDATE, 
							primaryOperand,
							new Time(System.currentTimeMillis()), 
							task);
		return result;
	}

}

	// End of segment: src\sg\codengineers\ldo\logic\UpdateHandler.java





	/**
	 * origin: src\sg\codengineers\ldo\model\Task.java
	 */


package sg.codengineers.ldo.model;

import java.util.Date;

/**
 * This interface exposes public functionality for a task
 */
public interface Task {
	
	public enum Priority {
		  LOW("low"),
		  NORMAL("normal"),
		  HIGH("high");

		  private String text;

		  Priority(String text) {
		    this.text = text;
		  }

		  public String getText() {
		    return this.text;
		  }

		  public static Priority fromString(String text) {
		    if (text != null) {
		      for (Priority b : Priority.values()) {
		        if (text.equalsIgnoreCase(b.text)) {
		          return b;
		        }
		      }
		    }
		    return null;
		  }
		}
	
	public void setParams(Task t);
	
	/**
	 * Gets the unique ID of each task
	 * @return Unique ID of the task
	 */
	public int getId();

	/**
	 * Gets the name of the task
	 * @return Name of task
	 */
	public String getName();

	/**
	 * Gets current status tagged with the task
	 * @return Status tagged to task
	 */
	public String getTag();
	
	/**
	 * Gets the description of the task
	 * @return The task description
	 */
	public String getDescription();
	
	/**
	 * Gets the time that the task should start
	 * @return Start time of the task
	 */
	public Date getStartTime();

	/**
	 * Gets the time that the task should end
	 * @return The end time of the task
	 */
	public Date getEndTime();

	/**
	 * Gets the deadline of the task for the user
	 * @return The task deadline
	 */
	public Date getDeadline();
	
	public Priority getPriority();
	
	public void setId(int id);
	
	public void setName(String name);
	
	public void setTag(String tag);
	
	public void setDescription(String description);
	
	public void setTimeStart(Date timeEnd);
	
	public void setTimeEnd(Date timeEnd);
	
	public void setDeadline(Date deadline);
	
	public void setPriority(Priority priority);
}

	// End of segment: src\sg\codengineers\ldo\model\Task.java





